# Unified Cluster Makefile
# Thin wrapper around bash scripts for CI/CD compatibility
# Called from root Makefile with CLUSTER_NAME variable
# Network type is read from terraform.tfvars

include Makefile.common

# Cluster name from root Makefile
CLUSTER_NAME ?= $(error CLUSTER_NAME must be set)

# Script directory
SCRIPT_DIR := scripts

# Directories
TERRAFORM_DIR := terraform
CLUSTER_DIR := clusters/$(CLUSTER_NAME)

# Check cluster exists
check-cluster:
	@$(SCRIPT_DIR)/utils/check-cluster.sh $(CLUSTER_NAME)

.PHONY: help init plan apply destroy destroy_force sleep fmt validate clean
.PHONY: show-endpoints show-credentials login
.PHONY: tunnel-start tunnel-stop tunnel-status bastion-connect
.PHONY: bootstrap-cluster

help: ## Show this help message
	@$(SCRIPT_DIR)/utils/get-network-config.sh $(CLUSTER_DIR) >/dev/null 2>&1 || true; \
	NETWORK_TYPE=$$(grep -E "^network_type\s*=" $(CLUSTER_DIR)/terraform.tfvars 2>/dev/null | sed -E 's/.*=\s*"([^"]+)"|.*=\s*([^"#\s]+).*/\1\2/' | tr -d ' ' || echo "unknown"); \
	ENABLE_STRICT_EGRESS=$$(grep -E "^enable_strict_egress\s*=" $(CLUSTER_DIR)/terraform.tfvars 2>/dev/null | sed -E 's/.*=\s*"([^"]+)"|.*=\s*([^"#\s]+).*/\1\2/' | tr -d ' ' || echo "false"); \
	if [ "$$NETWORK_TYPE" = "private" ] && [ "$$ENABLE_STRICT_EGRESS" = "true" ]; then \
		MODE="egress-zero"; \
	else \
		MODE="$$NETWORK_TYPE"; \
	fi; \
	echo "$(GREEN)Unified Cluster Management - $(CLUSTER_NAME) ($$MODE)$(NC)"; \
	echo ""; \
	echo "$(BLUE)Usage:$(NC) make cluster.$(CLUSTER_NAME).<operation>"; \
	echo ""; \
	echo "$(GREEN)Cluster Management:$(NC)"; \
	echo "  make cluster.$(CLUSTER_NAME).init              Initialize infrastructure"; \
	echo "  make cluster.$(CLUSTER_NAME).plan              Plan infrastructure changes"; \
	echo "  make cluster.$(CLUSTER_NAME).apply             Apply infrastructure"; \
	echo "  make cluster.$(CLUSTER_NAME).destroy           Destroy all resources (sets persists_through_sleep=false)"; \
	echo "  make cluster.$(CLUSTER_NAME).destroy_force     Destroy all resources without confirmation prompt"; \
	echo "  make cluster.$(CLUSTER_NAME).sleep             Sleep cluster (destroy with preserved resources)"; \
	echo ""; \
	echo "$(GREEN)GitOps:$(NC)"; \
	echo "  make cluster.$(CLUSTER_NAME).bootstrap-cluster Bootstrap GitOps operator on cluster"; \
	echo ""; \
	echo "$(GREEN)Cluster Access:$(NC)"; \
	echo "  make cluster.$(CLUSTER_NAME).show-endpoints    Show API and console URLs"; \
	echo "  make cluster.$(CLUSTER_NAME).show-credentials Show admin credentials and endpoints"; \
	echo "  make cluster.$(CLUSTER_NAME).login             Login to cluster using oc CLI"; \
	echo ""; \
	echo "$(GREEN)Bastion & Tunnel Management:$(NC)"; \
	echo "  make cluster.$(CLUSTER_NAME).tunnel-start      Start sshuttle VPN tunnel via bastion"; \
	echo "  make cluster.$(CLUSTER_NAME).tunnel-stop       Stop sshuttle tunnel"; \
	echo "  make cluster.$(CLUSTER_NAME).tunnel-status    Check if tunnel is running"; \
	echo "  make cluster.$(CLUSTER_NAME).bastion-connect   Connect to bastion via SSM Session Manager"; \
	echo ""; \
	echo "$(BLUE)Network Type:$(NC) $$NETWORK_TYPE (mode: $$MODE)"; \
	echo "$(BLUE)Available clusters:$(NC)"; \
	ls -1 clusters/ 2>/dev/null | sed 's/^/  - /' || echo "  (none)"

# Cluster operations
init: check-cluster
	@$(SCRIPT_DIR)/cluster/init-infrastructure.sh $(CLUSTER_NAME)
	@echo "$(GREEN)Initialized $(CLUSTER_NAME)$(NC)"

plan: init
	@$(SCRIPT_DIR)/cluster/plan-infrastructure.sh $(CLUSTER_NAME)
	@echo "$(GREEN)Planned $(CLUSTER_NAME)$(NC)"

apply: plan
	@$(SCRIPT_DIR)/cluster/apply-infrastructure.sh $(CLUSTER_NAME)
	@echo "$(GREEN)Applied $(CLUSTER_NAME)$(NC)"

destroy: check-cluster
	@$(SCRIPT_DIR)/cluster/destroy-infrastructure.sh $(CLUSTER_NAME)
	@echo "$(GREEN)Destroyed $(CLUSTER_NAME)$(NC)"
	@echo "$(GREEN)All resources have been deleted from AWS.$(NC)"

destroy_force: check-cluster
	@AUTO_APPROVE=true $(SCRIPT_DIR)/cluster/destroy-infrastructure.sh $(CLUSTER_NAME)
	@echo "$(GREEN)Destroyed $(CLUSTER_NAME)$(NC)"
	@echo "$(GREEN)All resources have been deleted from AWS.$(NC)"

sleep: check-cluster
	@AUTO_APPROVE=true $(SCRIPT_DIR)/cluster/cleanup-infrastructure.sh $(CLUSTER_NAME)
	@echo "$(GREEN)Cluster put to sleep for $(CLUSTER_NAME)$(NC)"
	@echo "$(GREEN)Cluster resources have been destroyed, but preserved resources remain:$(NC)"
	@echo "$(GREEN)  - DNS domain (if enable_persistent_dns_domain=true)$(NC)"
	@echo "$(GREEN)  - Admin password in AWS Secrets Manager$(NC)"
	@echo "$(GREEN)  - IAM roles and OIDC configuration$(NC)"
	@echo "$(GREEN)  - KMS keys and EFS (if not explicitly destroyed)$(NC)"
	@echo "$(GREEN)$(NC)"
	@echo "$(GREEN)To wake the cluster, run: make cluster.$(CLUSTER_NAME).apply$(NC)"

# GitOps operations
bootstrap-cluster: check-cluster
	@echo "$(BLUE)Bootstrapping GitOps operator for $(CLUSTER_NAME)...$(NC)"
	@cd $(TERRAFORM_DIR) && \
		if ! terraform output -no-color gitops_bootstrap_enabled 2>/dev/null | grep -q "true"; then \
			echo "$(YELLOW)Warning: GitOps bootstrap is not enabled for this cluster.$(NC)"; \
			echo "$(YELLOW)Set enable_gitops_bootstrap=true in terraform.tfvars and run terraform apply.$(NC)"; \
			exit 1; \
		fi && \
		SCRIPT_PATH=$$(terraform output -no-color -raw gitops_bootstrap_script_path 2>/dev/null | tr -d '\n\r' | sed 's/[[:space:]]*$$//') && \
		if [ -z "$$SCRIPT_PATH" ] || [ "$$SCRIPT_PATH" = "null" ]; then \
			echo "$(YELLOW)Error: GitOps bootstrap script path not found. Run terraform apply first.$(NC)"; \
			exit 1; \
		fi && \
		echo "$(BLUE)Exporting environment variables from Terraform outputs...$(NC)" && \
		eval $$(terraform output -no-color -raw gitops_bootstrap_command 2>/dev/null) && \
		echo "$(BLUE)Running GitOps bootstrap script: $$SCRIPT_PATH$(NC)" && \
		bash "$$SCRIPT_PATH" || \
		(echo "$(YELLOW)GitOps bootstrap failed. Check the output above for details.$(NC)" && exit 1)
	@echo "$(GREEN)GitOps bootstrap completed for $(CLUSTER_NAME)$(NC)"

# Info operations
show-endpoints: check-cluster
	@$(SCRIPT_DIR)/info/show-endpoints.sh $(CLUSTER_NAME)

show-credentials: show-endpoints
	@$(SCRIPT_DIR)/info/show-credentials.sh $(CLUSTER_NAME)

login: check-cluster
	@$(SCRIPT_DIR)/info/login.sh $(CLUSTER_NAME)

# Tunnel operations
tunnel-start: check-cluster
	@$(SCRIPT_DIR)/tunnel/start.sh $(CLUSTER_NAME)

tunnel-stop: check-cluster
	@$(SCRIPT_DIR)/tunnel/stop.sh $(CLUSTER_NAME)

tunnel-status: check-cluster
	@$(SCRIPT_DIR)/tunnel/status.sh $(CLUSTER_NAME)

# Bastion operations
bastion-connect: check-cluster
	@echo "$(BLUE)Connecting to bastion via SSM Session Manager...$(NC)"
	@if ! command -v aws >/dev/null 2>&1; then \
		echo "$(YELLOW)Error: aws CLI not found. Please install AWS CLI.$(NC)"; \
		exit 1; \
	fi
	@cd $(TERRAFORM_DIR) && \
		BASTION_ID=$$(terraform output -no-color -raw bastion_instance_id 2>/dev/null | tr -d '\n\r' | sed 's/[[:space:]]*$$//') && \
		if [ -z "$$BASTION_ID" ] || [ "$$BASTION_ID" = "null" ]; then \
			echo "$(YELLOW)Error: Bastion not deployed. Enable bastion with enable_bastion=true$(NC)"; \
			exit 1; \
		fi && \
		REGION=$$(terraform output -no-color -raw region 2>/dev/null | tr -d '\n\r' | sed 's/[[:space:]]*$$//' || terraform output -no-color -json 2>/dev/null | jq -r '.region.value // empty' | tr -d '\n\r' || echo "us-east-1") && \
		if [ -z "$$REGION" ]; then \
			REGION=$$(grep -E "^region\s*=" ../../$(CLUSTER_DIR)/terraform.tfvars 2>/dev/null | cut -d'"' -f2 | cut -d"'" -f2 | head -1 || echo "us-east-1"); \
		fi && \
		echo "$(GREEN)Connecting to bastion $$BASTION_ID in region $$REGION...$(NC)" && \
		aws ssm start-session --target $$BASTION_ID --region $$REGION || \
		(echo "$(YELLOW)Failed to connect. Check AWS credentials and bastion status.$(NC)" && exit 1)

# Validate
validate:
	@cd $(TERRAFORM_DIR) && terraform init -backend=false && terraform validate

# Format
fmt:
	@terraform fmt -recursive

# Clean
clean:
	@find . -type d -name ".terraform" -exec rm -rf {} + 2>/dev/null || true
	@find . -name ".terraform.lock.hcl" -delete 2>/dev/null || true
	@find . -name "terraform.tfplan" -delete 2>/dev/null || true
